import {
  _decorator, Component, Node, RigidBody2D, Vec2,
  input, Input, EventKeyboard, KeyCode,
  Label, director, tween, Vec3, Color, UITransform, AudioSource, AudioClip, Collider2D, Contact2DType, IPhysics2DContact, Sprite
} from 'cc';
const { ccclass, property } = _decorator;

@ccclass('Opp')
export class Player extends Component {
  @property(RigidBody2D) body!: RigidBody2D;
  @property(Label) scoreLabel!: Label;
  @property(Node) gameOverPanel!: Node;
  @property(Node) canvasNode: Node | null = null;

  @property(AudioSource) sfxSource: AudioSource = null!;
  @property(AudioClip) flipSfx: AudioClip = null!;
  @property(AudioClip) deathSfx: AudioClip = null!;

  // ü©∏ NEW: Lives system
  @property(Label) livesLabel: Label = null!;  // assign in editor
  private lives: number = 100;
  private drainPerObstacle: number = 1;
  private healPerStar: number = 15;

  // üíö NEW: Add Health variable (mirrors lives)
  private health: number = 100;

  private gravity = -10;
  private alive = true;
  private score = 0;
  private margin = 701;

  private rainbowColors: Color[] = [
    new Color(255, 0, 0),
    new Color(255, 127, 0),
    new Color(255, 255, 0),
    new Color(0, 255, 0),
    new Color(0, 0, 255),
    new Color(75, 0, 130),
    new Color(148, 0, 211),
  ];
  private rainbowIndex = 0;

  onLoad() {
    input.on(Input.EventType.TOUCH_START, this.flip, this);
    input.on(Input.EventType.KEY_DOWN, this.onKeyDown, this);
    if (this.body) this.body.gravityScale = this.gravity;
    this.schedule(this.tickScore, 1);

    if (this.gameOverPanel) this.gameOverPanel.active = false;

    const retryBtn = this.gameOverPanel?.getChildByName("RetryButton");
    if (retryBtn) {
      const btnComp = retryBtn.getComponent('cc.Button');
      if (btnComp) {
        retryBtn.on(Node.EventType.MOUSE_DOWN, this.retry, this);
        retryBtn.on(Node.EventType.TOUCH_END, this.retry, this);
      }
    }

    // ü©∏ Init lives label
    if (this.livesLabel) {
      this.livesLabel.string = `‚ù§Ô∏è ${this.lives}%`;
    }

    // üß± Detect collisions
    const collider = this.getComponent(Collider2D);
    if (collider) {
      collider.on(Contact2DType.BEGIN_CONTACT, this.onBeginContact, this);
    }
  }

  onDestroy() {
    input.off(Input.EventType.TOUCH_START, this.flip, this);
    input.off(Input.EventType.KEY_DOWN, this.onKeyDown, this);
    this.unschedule(this.tickScore);

    const collider = this.getComponent(Collider2D);
    if (collider) collider.off(Contact2DType.BEGIN_CONTACT, this.onBeginContact, this);
  }

  private onKeyDown(ev: EventKeyboard) {
    if (ev.keyCode === KeyCode.KEY_R) {
      this.gameOver();
    }
  }

  flip() {
    if (!this.alive) return;
    this.gravity *= -1;
    if (this.body) this.body.gravityScale = this.gravity;

    tween(this.node)
      .to(0.08, { scale: new Vec3(0.1, 0.8, 0.5) })
      .to(0.08, { scale: new Vec3(0.9, 0.9, 0.2) })
      .start();

    if (this.flipSfx && this.sfxSource) {
      this.sfxSource.playOneShot(this.flipSfx, 1);
    }

    if (this.body) {
      this.body.linearVelocity = new Vec2(0, this.gravity > 0 ? -6 : 7);
    }
  }

  tickScore() {
    if (!this.alive) return;
    this.score++;
    if (this.scoreLabel) {
      this.scoreLabel.string = `${this.score}`;
      this.scoreLabel.node.scale = new Vec3(1, 1, 1);
      tween(this.scoreLabel.node)
        .to(0.1, { scale: new Vec3(2.4, 2.4, 2) })
        .to(0.1, { scale: new Vec3(4, 4, 4) })
        .start();

      const col = this.rainbowColors[this.rainbowIndex];
      this.rainbowIndex = (this.rainbowIndex + 1) % this.rainbowColors.length;
      this.scoreLabel.color = col;
    }

    // ‚ö° Lives auto drain if not collecting stars (optional)
    this.modifyLives(-1);
  }

  // ü©∏ Handle collisions
  private onBeginContact(selfCollider: Collider2D, otherCollider: Collider2D, contact: IPhysics2DContact | null) {
    if (!this.alive) return;

    const otherName = otherCollider.node.name.toLowerCase();

    if (otherName.includes("obstacle")) {
      this.modifyLives(-this.drainPerObstacle);
      this.flashDamage();
      this.showFloatingText("-" + this.drainPerObstacle, new Color(255, 80, 80)); // üî¥ popup
      otherCollider.node.destroy(); // üí• make obstacle disappear after hit
    } else if (otherName.includes("star")) {
      this.modifyLives(this.healPerStar);
      this.flashHeal();
      this.showFloatingText("+" + this.healPerStar, new Color(300, 255, 100)); // üü¢ popup
      otherCollider.node.destroy(); // remove star
    }
  }

  // ü©∏ Modify lives with bounds
  private modifyLives(amount: number) {
    this.lives = Math.min(100, Math.max(0, this.lives + amount));
    this.health = this.lives; // üîÅ keep health synced
    if (this.livesLabel) this.livesLabel.string = `‚ù§Ô∏è ${this.lives}%`;
    if (this.lives <= 0) this.gameOver();
  }

  // ü©∏ Flash red effect on hit
  private flashDamage() {
    const sprite = this.node.getComponent(Sprite);
    if (!sprite) return;

    const originalColor = sprite.color.clone();
    sprite.color = new Color(255, 50, 50); // red
    tween(sprite)
      .delay(0.1)
      .call(() => { sprite.color = originalColor; })
      .start();

    tween(this.node)
      .to(0.05, { scale: new Vec3(0.6, 0.6, 1) })
      .to(0.05, { scale: new Vec3(1, 1, 1) })
      .start();
  }

  // üíö Flash green effect on heal
  private flashHeal() {
    const sprite = this.node.getComponent(Sprite);
    if (!sprite) return;

    const originalColor = sprite.color.clone();
    sprite.color = new Color(50, 255, 50); // green
    tween(sprite)
      .delay(0.1)
      .call(() => { sprite.color = originalColor; })
      .start();
  }

  // üåü Floating text popup
  private showFloatingText(text: string, color: Color) {
    const canvas = this.canvasNode ?? director.getScene()!.getChildByName('Canvas');
    if (!canvas) return;

    const popup = new Node("PopupText");
    const label = popup.addComponent(Label);
    label.string = text;
    label.color = color;
    label.fontSize = 28;
    popup.setPosition(this.node.worldPosition);
    canvas.addChild(popup);

    tween(popup)
      .by(0.6, { position: new Vec3(0, 70, 0) })
      .to(0.2, { scale: new Vec3(0, 0, 0) })
      .call(() => popup.destroy())
      .start();
  }

  update() {
    if (!this.alive) return;

    const canvas = this.canvasNode ?? director.getScene()!.getChildByName('Canvas');
    if (!canvas) return;

    const ui = canvas.getComponent(UITransform);
    if (!ui) return;

    const halfH = ui.contentSize.height / 2;
    const y = this.node.position.y;

    if (y > halfH + this.margin || y < -halfH - this.margin) {
      this.gameOver();
    }

    // ‚ö°Ô∏è NEW: Proximity-based Star + Obstacle detection (backup to physics)
    const scene = director.getScene();
    if (!scene) return;
    const allNodes = scene.children;
    for (const node of allNodes) {
      const name = node.name.toLowerCase();
      if (name.includes("star") || name.includes("obstacle")) {
        const dist = Vec3.distance(this.node.worldPosition, node.worldPosition);
        if (dist < 80) { // adjust this based on sprite size
          if (name.includes("star")) {
            this.modifyLives(this.healPerStar);
            this.flashHeal();
            this.showFloatingText("+" + this.healPerStar, new Color(100, 255, 100));
            node.destroy();
          } else if (name.includes("obstacle")) {
            this.modifyLives(-this.drainPerObstacle);
            this.flashDamage();
            this.showFloatingText("-" + this.drainPerObstacle, new Color(255, 80, 80));
            node.destroy(); // üí• make obstacle disappear after proximity hit
          }
        }
      }
    }
  }

  gameOver() {
    if (!this.alive) return;
    this.alive = false;
    this.unschedule(this.tickScore);

    if (this.sfxSource && this.deathSfx) {
      this.sfxSource.stop();
      this.sfxSource.playOneShot(this.deathSfx, 1);
    }

    if (this.gameOverPanel) this.gameOverPanel.active = true;

    const cam = director.getScene()!.getChildByName('Main Camera');
    if (cam) {
      const originalPos = cam.position.clone();
      tween(cam)
        .to(0.05, { position: originalPos.add3f(10, 0, 0) })
        .to(0.05, { position: originalPos.add3f(-20, 0, 0) })
        .to(0.05, { position: originalPos.add3f(10, 0, 0) })
        .to(0.05, { position: originalPos })
        .start();
    }

    const bgmNode = director.getScene()!.getChildByName("BGM");
    if (bgmNode) {
      const bgmSource = bgmNode.getComponent(AudioSource);
      if (bgmSource && bgmSource.playing) {
        bgmSource.stop();
      }
    }
  }

  retry() {
    director.loadScene(director.getScene()!.name!);
  }
}
