import {
  _decorator, Component, Node, RigidBody2D, Vec2,
  input, Input, EventKeyboard, KeyCode,
  Label, director, tween, Vec3, Color, UITransform, AudioSource, AudioClip, Collider2D, Contact2DType, IPhysics2DContact
} from 'cc';
const { ccclass, property } = _decorator;

@ccclass('Opp')
export class Player extends Component {
  @property(RigidBody2D) body!: RigidBody2D;
  @property(Label) scoreLabel!: Label;
  @property(Node) gameOverPanel!: Node;
  @property(Node) canvasNode: Node | null = null;

  @property(AudioSource) sfxSource: AudioSource = null!;
  @property(AudioClip) flipSfx: AudioClip = null!;
  @property(AudioClip) deathSfx: AudioClip = null!;

  // ü©∏ NEW: Lives system
  @property(Label) livesLabel: Label = null!;  // assign in editor
  private lives: number = 100;
  private drainPerObstacle: number = 10;
  private healPerStar: number = 5;

  private gravity = -10;
  private alive = true;
  private score = 0;
  private margin = 701;

  private rainbowColors: Color[] = [
    new Color(255, 0, 0),
    new Color(255, 127, 0),
    new Color(255, 255, 0),
    new Color(0, 255, 0),
    new Color(0, 0, 255),
    new Color(75, 0, 130),
    new Color(148, 0, 211),
  ];
  private rainbowIndex = 0;

  onLoad() {
    input.on(Input.EventType.TOUCH_START, this.flip, this);
    input.on(Input.EventType.KEY_DOWN, this.onKeyDown, this);
    if (this.body) this.body.gravityScale = this.gravity;
    this.schedule(this.tickScore, 1);

    if (this.gameOverPanel) this.gameOverPanel.active = false;

    const retryBtn = this.gameOverPanel?.getChildByName("RetryButton");
    if (retryBtn) {
      const btnComp = retryBtn.getComponent('cc.Button');
      if (btnComp) {
        retryBtn.on(Node.EventType.MOUSE_DOWN, this.retry, this);
        retryBtn.on(Node.EventType.TOUCH_END, this.retry, this);
      }
    }

    // ü©∏ Init lives label
    if (this.livesLabel) {
      this.livesLabel.string = `‚ù§Ô∏è ${this.lives}%`;
    }

    // üß± Detect collisions
    const collider = this.getComponent(Collider2D);
    if (collider) {
      collider.on(Contact2DType.BEGIN_CONTACT, this.onBeginContact, this);
    }
  }

  onDestroy() {
    input.off(Input.EventType.TOUCH_START, this.flip, this);
    input.off(Input.EventType.KEY_DOWN, this.onKeyDown, this);
    this.unschedule(this.tickScore);

    const collider = this.getComponent(Collider2D);
    if (collider) collider.off(Contact2DType.BEGIN_CONTACT, this.onBeginContact, this);
  }

  private onKeyDown(ev: EventKeyboard) {
    if (ev.keyCode === KeyCode.KEY_R) {
      this.gameOver();
    }
  }

  flip() {
    if (!this.alive) return;
    this.gravity *= -1;
    if (this.body) this.body.gravityScale = this.gravity;

    tween(this.node)
      .to(0.08, { scale: new Vec3(0.1, 0.8, 0.5) })
      .to(0.08, { scale: new Vec3(0.9, 0.9, 0.2) })
      .start();

    if (this.flipSfx && this.sfxSource) {
      this.sfxSource.playOneShot(this.flipSfx, 1);
    }

    if (this.body) {
      this.body.linearVelocity = new Vec2(0, this.gravity > 0 ? -6 : 7);
    }
  }

  tickScore() {
    if (!this.alive) return;
    this.score++;
    if (this.scoreLabel) {
      this.scoreLabel.string = `${this.score}`;
      this.scoreLabel.node.scale = new Vec3(1, 1, 1);
      tween(this.scoreLabel.node)
        .to(0.1, { scale: new Vec3(2.4, 2.4, 2) })
        .to(0.1, { scale: new Vec3(4, 4, 4) })
        .start();

      const col = this.rainbowColors[this.rainbowIndex];
      this.rainbowIndex = (this.rainbowIndex + 1) % this.rainbowColors.length;
      this.scoreLabel.color = col;
    }

    // ‚ö° Lives auto drain if not collecting stars (optional)
    this.modifyLives(-1);
  }

  // ü©∏ Handle collisions
  private onBeginContact(selfCollider: Collider2D, otherCollider: Collider2D, contact: IPhysics2DContact | null) {
    if (!this.alive) return;

    const otherName = otherCollider.node.name.toLowerCase();

    if (otherName.includes("obstacle")) {
      this.modifyLives(-this.drainPerObstacle);
      this.flashDamage();
    } else if (otherName.includes("star")) {
      this.modifyLives(this.healPerStar);
      otherCollider.node.destroy(); // remove star
    }
  }

  // ü©∏ Modify lives with bounds
  private modifyLives(amount: number) {
    this.lives = Math.min(100, Math.max(0, this.lives + amount));
    if (this.livesLabel) this.livesLabel.string = `‚ù§Ô∏è ${this.lives}%`;
    if (this.lives <= 0) this.gameOver();
  }

  // ü©∏ Flash red effect
  private flashDamage() {
    tween(this.node)
      .to(0.05, { scale: new Vec3(0.6, 0.6, 1) })
      .to(0.05, { scale: new Vec3(1, 1, 1) })
      .start();
  }

  update() {
    if (!this.alive) return;

    const canvas = this.canvasNode ?? director.getScene()!.getChildByName('Canvas');
    if (!canvas) return;

    const ui = canvas.getComponent(UITransform);
    if (!ui) return;

    const halfH = ui.contentSize.height / 2;
    const y = this.node.position.y;

    if (y > halfH + this.margin || y < -halfH - this.margin) {
      this.gameOver();
    }

    // ‚ö°Ô∏è NEW: Proximity-based Star + Obstacle detection (backup to physics)
    const scene = director.getScene();
    if (!scene) return;
    const allNodes = scene.children;
    for (const node of allNodes) {
      const name = node.name.toLowerCase();
      if (name.includes("star") || name.includes("obstacle")) {
        const dist = Vec3.distance(this.node.worldPosition, node.worldPosition);
        if (dist < 80) { // adjust this based on sprite size
          if (name.includes("star")) {
            this.modifyLives(this.healPerStar);
            node.destroy();
          } else if (name.includes("obstacle")) {
            this.modifyLives(-this.drainPerObstacle);
            this.flashDamage();
          }
        }
      }
    }
  }

  gameOver() {
    if (!this.alive) return;
    this.alive = false;
    this.unschedule(this.tickScore);

    if (this.sfxSource && this.deathSfx) {
      this.sfxSource.stop();
      this.sfxSource.playOneShot(this.deathSfx, 1);
    }

    if (this.gameOverPanel) this.gameOverPanel.active = true;

    const cam = director.getScene()!.getChildByName('Main Camera');
    if (cam) {
      const originalPos = cam.position.clone();
      tween(cam)
        .to(0.05, { position: originalPos.add3f(10, 0, 0) })
        .to(0.05, { position: originalPos.add3f(-20, 0, 0) })
        .to(0.05, { position: originalPos.add3f(10, 0, 0) })
        .to(0.05, { position: originalPos })
        .start();
    }

    const bgmNode = director.getScene()!.getChildByName("BGM");
    if (bgmNode) {
      const bgmSource = bgmNode.getComponent(AudioSource);
      if (bgmSource && bgmSource.playing) {
        bgmSource.stop();
      }
    }
  }

  retry() {
    director.loadScene(director.getScene()!.name!);
  }
}
